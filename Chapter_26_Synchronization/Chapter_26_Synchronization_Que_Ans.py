import threading
import random
import queue
import time
import collections

"""
Que 5:- Write a program that has three threads in it. The first thread should produce random number in range 1 to 20.
        second thread should display the square of number generated by first thread on the screen, and 
        the third thread should write a cube of number generated by first thread into file. 

# Answer starts here..


def generate():
    for i in range(10):
        cond.acquire()
        num = random.randrange(10, 20)
        print('Generated number =', num)
        qfors.append(num)
        qforc.append(num)
        cond.notify_all()
        cond.release()


def square():
    for i in range(10):
        cond.acquire()
        if len(qfors):
            num = qfors.popleft()
            print('num =', num, 'Square =', num * num)
        cond.notify_all()
        cond.release()


def cube():
    f = open('cubes.txt', 'w')
    for i in range(10):
        cond.acquire()
        if len(qforc):
            num = qforc.popleft()

            f.write('num = ' + str(num) + ' cube = ' + str(num * num * num) + '\n')
        cond.notify_all()
        cond.release()
    f.close()


qfors = collections.deque()
qforc = collections.deque()
cond = threading.Condition()

th1 = threading.Thread(target=generate)
th2 = threading.Thread(target=square)
th3 = threading.Thread(target=cube)

th1.start()
th2.start()
th3.start()

th1.join()
th2.join()
th3.join()


print('All Done!!')

"""


"""
Que 6:- Suppose one thread is producing number from 1 to n and another thread is printing produced numbers.
        comment on the output that we are likely to get.

# Answer starts here...


# producer thread
def number_producer(n):
    print('Generating numbers...')
    for i in range(1, n+1):
        num = random.randrange(10, 30)
        lock.acquire()          # Ensure that the list is accessed safely
        number_arr.append(num)
        lock.release()

    ev.set()  # Notify consumer that numbers are ready


# consumer thread
def consume_number():
    print('Waiting for numbers to be produced...')
    ev.wait()
    lock.acquire()
    for num in number_arr:
        print(f'The number is {num}')
    lock.release()
    ev.clear()


ev = threading.Event()
number_arr = []
lock = threading.Lock()

user_input = int(input("Enter a positive integer to generate numbers up to that value: "))


th1 = threading.Thread(target=number_producer, args=(user_input,))
th2 = threading.Thread(target=consume_number)

th1.start()
th2.start()

th1.join()
th2.join()

print("All threads completed.")


"""


"""
Que 7:- what will happen if thread t1 waits for thread t2 to finish and thread t2 wait for thread one to finish

Answer starts here...

"""


def thread1():
    print("Thread 1 is starting")

    """
    # This results in Thread 1 waiting for Thread 2 and Thread 2 waiting for Thread 1, which causes a deadlock.
    # uncommenting below line will raise dead lock
    """
    # t2.join()  # Thread 1 waits for Thread 2 to finish
    print("Thread 1 is finished")


def thread2():
    print("Thread 2 is starting")
    t1.join()  # Thread 2 waits for Thread 1 to finish
    print("Thread 2 is finished")


# Create two threads
t1 = threading.Thread(target=thread1)
t2 = threading.Thread(target=thread2)

t1.start()
t2.start()

t1.join()  # Main thread waits for Thread 1
t2.join()  # Main thread waits for Thread 2

print("Both threads are finished.")



















